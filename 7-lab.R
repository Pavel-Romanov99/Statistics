
install.packages("tidyverse")

library(MASS)
library(magrittr)
library(dplyr)

#сумата на нормалните разпределения на х1 + ... + хн е равно на нормално разпределение
#което има за център мю сумата от центровете на останалите и вероятност сигма квадрат
#която е сума на тези на нормалните разпределения на х-овете

#тоест x1 + ... + xn e N( n * mu, n * sigma^2) and sum(Xi) - n * mu / n * sigma^2 принаглежи на   N(0, 1)!!!

#zad1 

#това е корен от второто число, дадено ни в задачата (вероятността)
my_sd <- 2

n <- 20

#генерираме симулации на нормално разпределени сл.в. със дадено средно и вероятност
x <- rnorm(n, mean = 3, my_sd)

m <- mean(x)

#това е квартил, в който попадат 97.5 процента от данните на графиката
q <- qnorm(p = 0.975)

#в 97,5% от случайте нашето мат очакване попада между двете стойности на този вектор
c(m - q * (my_sd / sqrt(n)), m + q * (my_sd / sqrt(n)))

t.test(x)


#zad2


leuk <- c(10.0, 13.6, 13.2, 11.6, 12.5, 14.2, 14.9, 14.5, 13.4, 8.6, 11.5, 16.0, 14.2, 16.8, 17.9, 17.8)

#normal distribution
qqnorm(leuk)

#понеже вектора горе е нормално разпределен, то сумата от норм разпределени сл.в е т разпределение и можем 
#да ползваме t.test

t.test(leuk, conf.level = 0.95 )

#ако данните ни не са нормално разпределени то се ползва
wilcox.test(leuk, conf.level = )


#zad3
library(UsingR)

#гледаме дали е нормално разпределено
qqnorm(rat)
qqline(rat)
#то е и съответно правим t.test
t.test(rat, conf.level = 0.96)

#не е нормално разпределено като гледаме графиката и ползваме другата ф-я
qqnorm(exec.pay)
wilcox.test(exec.pay, conf.level = 0.96, conf.int = TRUE)